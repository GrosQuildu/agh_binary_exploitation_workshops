### Reverse engineering

#### Downloads

* gdb
* [pwndbg](https://github.com/pwndbg/pwndbg)
* [Ghidra](https://ghidra-sre.org/) or [IDA](https://www.hex-rays.com/products/ida/support/download.shtml)
* [Veles (optional)](https://codisec.com/veles/#download-veles)

#### Warmup
* Challenges
    * random
    * cmd1 / cmd2

#### Basic linux tools

* file

* xxd / strings

* sha1sum / ssdeep / diff

* Challenges
    * crackme0x00a
    * crackme0x00b
    * todo challenge diff

#### Linux ELF

* File formats
```
Relocatable file -> Executable file
Relocatable file -> Shared object
```

* readelf / objdump / veles
```
Headers
    readelf -h

Section header table (sections)
    Linking view
    readelf -S

Program header table (segments)
    Execution view
    readelf -l

Relocations
    readelf -r

Dynamic
    readelf -d
```

![Sections/Segments](/lab1/img/elf1.png  "http://www.skyfree.org/linux/references/ELF_Format.pdf")

* Linking
    * ldd
    * ltrace / strace

* Challenges
    * fixme0x0a
    * trace
    * preload todo

#### Assembly

* The code
```
$ objdump -d -M intel -j.text crackme0x00b | grep '<main>' -A 10
08048494 <main>:
8048494:   55                      push   ebp
8048495:   89 e5                   mov    ebp,esp
8048497:   83 e4 f0                and    esp,0xfffffff0
804849a:   83 c4 80                add    esp,0xffffff80
804849d:   b8 d0 85 04 08          mov    eax,0x80485d0
80484a2:   89 04 24                mov    DWORD PTR [esp],eax
80484a5:   e8 d6 fe ff ff          call   8048380 <printf@plt>
80484aa:   b8 e1 85 04 08          mov    eax,0x80485e1
80484af:   8d 54 24 1c             lea    edx,[esp+0x1c]
80484b3:   89 54 24 04             mov    DWORD PTR [esp+0x4],edx

Addresses  Raw bytes               Mnemonics   Operands
```

* Registers
    ![X86 registers](/lab1/img/x86-registers.png  "http://flint.cs.yale.edu/cs421/papers/x86-asm/x86-registers.png")

* Basic x86 asm operations

| Command | Description |
| --- | --- |
| mov eax, 5 | eax = 5  |
| lea ebx, [eax-0x20]  | ebx = eax-20  |
| mov eax, [ebx + ecx*4 + 0x6] | eax = *(ebx + ecx*4 + 6) |
| lea eax, [ebx + ecx*4 + 0x6] | eax = ebx + ecx*4 + 6 |
| push eax  | Push eax into stack  |
| pop eax | Pop eax from stack  |
| jmp eax | eip = eax  |
| cmp eax, 0xe | set bits in EFLAGS  |
| jz $+10 | if ZF=1 then eip = eip+10  |
| ja $+10 | if  ZF=0 && CF=0 then eip = eip+10  |
| jg $+10 | if  ZF=0 && SF = OF then eip = eip+10  |

* (pwn)gdb

* Virtual map
    * Sections / stack

* Function calls
    * Prologue / epilogue
    * Calling conventions

* Challenges
    * crackme0x01

#### Dissassembly
 * Linear / recursive
     * anti_disasm

 * IDA / Ghidra

 * Challenges
     * crackme0x03
     * crackme0x04
     * crackme0x09

#### Home
 * bomb
 * lab1
 * lab2
 * lab3

#### Resources
 * [RPISEC](https://github.com/RPISEC/MBE)
 * [ELF format](http://www.skyfree.org/linux/references/ELF_Format.pdf)
 * [challenges.re](https://challenges.re/)
 * [Securitytraps](https://www.securitytraps.pl/)
 * [OverTheWire](http://overthewire.org)
